#play удовлетворяет требованиям:
#s - входной параметр
#arr - последовательность ходов
#возвращает 1, если на каком-то из ходов arr первый игрок первым достигает победы
#возвращает 2, если на каком-то из ходов arr второй игрок первым достигает победы
#возвращает 0, если arr не приводит к победе
#
#не предполагает случай, когда последовательность arr невозможна
#частным решением проблемы может быть подгон arr под возможную комбинацию(в случае, если вместо одного хода можно однозначно выбрать другой)
#частным решением проблемы может быть ограничение перебора внутри must и have

#на ход протагониста(длина массива должна быть четной)
#(имеется стратегия игры при сделанных ходах arr)
#(т.е. найдется ход, который при уже сделанных ходах arr обязательно приведет к победе)
def have(s, arr = [], depth=1000):
    res = play(s,arr)
    if res != 0:
        return res == len(arr)%2+1
    if depth == 0:
        return False
    f = False
    for i in range(4):      #перебор всех ходов протагониста(вместо range(4) может быть массив типов ходов)
        f = f or must(s,arr+[i],depth-1)
    return f

#на ход антагониста(длина массива должна быть нечетной)
#(может выиграть при сделанных ходах arr)
#(т.е. на любой ход при уже сделанных ходах arr найдется стратегия)
def must(s, arr = [], depth=1000):
    res = play(s,arr)
    if res != 0:
        return res != len(arr)%2+1
    if depth == 0:
        return False
    f = True
    for i in range(4):      #перебор всех ходов антагониста(вместо range(4) может быть массив типов ходов)
        f = f and have(s,arr+[i],depth-1)
    return f

for s in range(1,70):
    if not must(s, [], 2) and must(s,[],4):
        print(s)

#depth равен максимальному количеству рассматриваемых ходов(и протагониста, и антагониста)


#Пример употребления
have(s,[], 3) #первый игрок имеет стратегию, позволяющую выиграть за 1 или 2 его хода при любом ходе второго игрока
not have(s,[],1) #первый игрок не имеет стратегии, позволяющей выиграть за 1 ход
must(s,[],4) #второй игрок может выиграть не более чем за 2 своих хода при любых первых двух ходах первого игрока(т.е. имеет стратегию)

have(s,[0,0,1,1]) #первый игрок имеет стратегию, позволяющую выиграть при сделанной последовательности ходов 0,0,1,1

#Предупреждение: алгоритм работает за O(x^n), где x-кол-во возможных действий за один ход, n - кол-во ходов
#Оценка: 1 секунда: n=24 x=2
#Оценка: 10 секунд: n=28 x=2
#Оценка: 100 секунд: n=31 x=2
