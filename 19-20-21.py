'''
play удовлетворяет требованиям:
s - входной параметр
arr - последовательность ходов
возвращает 1, если на каком-то из ходов arr первый игрок первым достигает победы
возвращает 2, если на каком-то из ходов arr второй игрок первым достигает победы
возвращает 0, если arr не приводит к победе

не предполагает случай, когда последовательность arr невозможна
частным решением проблемы может быть подгон arr под возможную комбинацию(в случае, если вместо одного хода можно однозначно выбрать другой)
частным решением проблемы может быть ограничение перебора внутри must и have
'''

#пример play для условия:

#Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч один камень или увеличить количество камней в куче в два раза. Чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Игра завершается в тот момент, когда суммарное количество камней в кучах становится не менее 77. Победителем считается игрок, сделавший последний ход, т. е. первым получивший позицию, в которой в кучах будет 77 или больше камней.
#В начальный момент в первой куче было 7 камней, во второй куче – S камней, 1 ≤ S ≤ 69. Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
#Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Назовите минимальное значение S, при котором это возможно.


#возвращает новые значения a,b(размеры куч) при ходе m
def move(a, b, m):
    if m == 0:
        return a+1,b
    if m == 1:
        return a*2,b
    if m == 2:
        return a,b+1
    return a,b*2


def play(s, arr):
    a = 7
    b = s
    for i in len(arr):
        #делаем ход
        a,b = move(a,b,arr[i])

        #проверяем условие победы
        if a+b >= 77:
            return i%2+1
    return 0

moves = range(4)        #коллекция типов ходов

'''
на ход протагониста(длина массива должна быть четной)
(имеется стратегия игры при сделанных ходах arr)
(т.е. найдется ход, который при уже сделанных ходах arr обязательно приведет к победе)
depth равен максимальному количеству рассматриваемых ходов(и протагониста, и антагониста)
'''
def have(s, arr = [], depth=1000):
    res = play(s,arr)
    if res != 0:
        return res == len(arr)%2+1
    if depth == 0:
        return False
    f = False
    for i in moves:      #перебор всех ходов протагониста
        f = f or must(s,arr+[i],depth-1)
    return f

'''
на ход антагониста(длина массива должна быть нечетной)
(может выиграть при сделанных ходах arr)
(т.е. на любой ход при уже сделанных ходах arr найдется стратегия)
depth равен максимальному количеству рассматриваемых ходов(и протагониста, и антагониста)
'''
def must(s, arr = [], depth=1000):
    res = play(s,arr)
    if res != 0:
        return res != len(arr)%2+1
    if depth == 0:
        return False
    f = True
    for i in moves:      #перебор всех ходов антагониста
        f = f and have(s,arr+[i],depth-1)
    return f


#Пример употребления
have(s,[], 3) #первый игрок имеет стратегию, позволяющую выиграть за 1 или 2 его хода при любом ходе второго игрока
not have(s,[],1) #первый игрок не имеет стратегии, позволяющей выиграть за 1 ход
must(s,[],4) #второй игрок может выиграть не более чем за 2 своих хода при любых первых двух ходах первого игрока(т.е. имеет стратегию)

have(s,[0,0,1,1]) #первый игрок имеет стратегию, позволяющую выиграть при сделанной последовательности ходов 0,0,1,1

#Предупреждение: алгоритм работает за O(x^n), где x-кол-во возможных действий за один ход, n - кол-во ходов
#Оценка: 1 секунда: n=24 x=2
#Оценка: 10 секунд: n=28 x=2
#Оценка: 100 секунд: n=31 x=2
