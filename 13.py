neighbors = {
    'А': 'БВГ',   #из А можно добраться в Б, В, Г
    'Б': 'ВД',
    'В': 'ЖД',
    'Г': 'ВЕ',
    'Д': 'ИК',
    'Е': 'ЖК',
    'Ж': 'К',
    'И': 'К',
    'К': ''
}


# кол-во способов попасть из frm в to, пройдя через need и не проходя через banned
def cnt(frm, to, need='', banned=''):
    if frm in need:
        need = need.replace(frm, '')        #если прошли через необходимую вершину, то удаляем ее из списка и в следующих вызовах уже эту вершину не требуем
    if frm in banned:
        return 0    #если мы попали в забаненную вершину, то возвращаем 0, т.е. нет путей из этой точки, не проходящих через забаненные вершины
    if frm == to:
        return int(len(need) == 0)      #вернет 1, если у нас не осталось непройденных вершин в need, иначе вернет 0 
                                        #(если по условию задачи need не используется(т.е. он всегда будет пустым), то просто возвращай 1)
  
    return sum([cnt(i, to, need, banned) for i in neighbors[frm]])      #количество путей из данной вершины - это сумма количеств путей из соседей(т.е. вершин, в которые мы можем попасть из данной)


cnt('А', 'К')  # кол-во способов попасть из А в К
cnt('А', 'К', 'ВЖ')  # кол-во способов попасть из А в К, пройдя через В и Ж
cnt('А', 'К', 'ВЖ', 'И')  # кол-во способов попасть из А в К, пройдя через В и Ж и не проходя через И
cnt('А', 'К', '', 'И')  # кол-во способов попасть из А в К, не проходя через И

(cnt('А', 'К', 'Б') - cnt('А', 'К', 'БВ')) + (cnt('А', 'К', 'В') - cnt('А', 'К', 'БВ'))  # кол-во способов попасть из А в К, пройдя через Б или В, но не через оба сразу
cnt('А', 'К', 'Б') + cnt('А', 'К', 'В') - 2 * cnt('А', 'К', 'БВ')  # то же, что и в предыдущей строке
